#!/usr/bin/env python3
# curtin-hooks - Curtin installation hooks for Ubuntu
#
# Copyright (C) 2022 Canonical
#
# This program is free software: you can redistribute it and/or modify
# it under the terms of the GNU Affero General Public License as
# published by the Free Software Foundation, either version 3 of the
# License, or (at your option) any later version.
#
# This program is distributed in the hope that it will be useful,
# but WITHOUT ANY WARRANTY; without even the implied warranty of
# MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
# GNU Affero General Public License for more details.
#
# You should have received a copy of the GNU Affero General Public License
# along with this program.  If not, see <http://www.gnu.org/licenses/>.

import os
import shutil
import glob
import yaml

from curtin.commands.curthooks import builtin_curthooks
from curtin.config import load_command_config
from curtin.util import load_command_environment


def configure_proxmox_network(config, target):
    """Convert MAAS netplan config to Proxmox /etc/network/interfaces.

    Reads network configuration from curtin config (provided by MAAS),
    and converts to /etc/network/interfaces format with vmbr0 bridge.
    """
    print("=" * 80)
    print("CURTIN-HOOKS: Converting netplan to Proxmox network configuration...")
    print("=" * 80)

    # Read network config from curtin config (MAAS provides this during deployment)
    network_config = config.get('network', {})

    print(f"DEBUG: Full network config received from MAAS:")
    print(yaml.dump(network_config, default_flow_style=False, indent=2))
    print("-" * 80)

    if not network_config:
        print("WARNING: No network config found in curtin config")
        return

    # Extract network configuration
    network = network_config.get('config', network_config)
    if isinstance(network, str):
        # If it's a string, try to parse it as YAML
        network = yaml.safe_load(network)

    # Handle both network.config and direct network format
    if 'network' in network:
        network = network['network']

    ethernets = network.get('ethernets', {})
    bonds = network.get('bonds', {})

    # Find the interface with IP configuration (check bonds first, then ethernets)
    configured = False
    bridge_port = None
    ip_address = None
    gateway = None
    dns_servers = None
    bond_config = None

    # Check for bonds first (priority over direct ethernet)
    for bond_name, bond_cfg in bonds.items():
        if 'addresses' in bond_cfg and bond_cfg['addresses']:
            bridge_port = bond_name
            ip_address = bond_cfg['addresses'][0]
            gateway = bond_cfg.get('gateway4') or bond_cfg.get('gateway')
            nameservers = bond_cfg.get('nameservers', {})
            dns_servers = nameservers.get('addresses', ['8.8.8.8', '8.8.4.4'])

            # Extract bond configuration
            bond_params = bond_cfg.get('parameters', {})
            bond_interfaces = bond_cfg.get('interfaces', [])

            bond_config = {
                'name': bond_name,
                'interfaces': bond_interfaces,
                'mode': bond_params.get('mode', '802.3ad'),
                'miimon': bond_params.get('mii-monitor-interval', 100),
                'lacp_rate': bond_params.get('lacp-rate', 'fast'),
                'xmit_hash_policy': bond_params.get('transmit-hash-policy', 'layer2+3'),
            }

            print(f"DEBUG: Found bond {bond_name} with IP configuration")
            print(f"  - Bond slaves: {bond_interfaces}")
            print(f"  - Bond mode: {bond_config['mode']}")
            break

    # If no bond found, check ethernet interfaces
    if not bridge_port:
        for iface_name, iface_cfg in ethernets.items():
            if 'addresses' in iface_cfg and iface_cfg['addresses']:
                bridge_port = iface_name
                ip_address = iface_cfg['addresses'][0]
                gateway = iface_cfg.get('gateway4') or iface_cfg.get('gateway')
                nameservers = iface_cfg.get('nameservers', {})
                dns_servers = nameservers.get('addresses', ['8.8.8.8', '8.8.4.4'])
                print(f"DEBUG: Found ethernet interface {iface_name} with IP configuration")
                break

    if not bridge_port:
        print("WARNING: No interface with IP address found in netplan config")
        return

    print(f"DEBUG: Configuring bridge vmbr0 on {bridge_port}")
    print(f"  - IP Address: {ip_address}")
    print(f"  - Gateway: {gateway}")
    print(f"  - DNS Servers: {dns_servers}")

    # Write /etc/network/interfaces
    interfaces_path = os.path.join(target, "etc/network/interfaces")
    interfaces_content = []
    interfaces_content.append("# network interface settings; autogenerated by curtin\n")
    interfaces_content.append("# Converted from netplan for Proxmox VE compatibility\n")
    interfaces_content.append("\n")
    interfaces_content.append("auto lo\n")
    interfaces_content.append("iface lo inet loopback\n")
    interfaces_content.append("\n")

    # Configure bond if present
    if bond_config:
        # Configure bond slave interfaces
        for slave_iface in bond_config['interfaces']:
            interfaces_content.append(f"auto {slave_iface}\n")
            interfaces_content.append(f"iface {slave_iface} inet manual\n")
            interfaces_content.append(f"    bond-master {bond_config['name']}\n")
            interfaces_content.append("\n")

        # Configure bond interface
        interfaces_content.append(f"auto {bond_config['name']}\n")
        interfaces_content.append(f"iface {bond_config['name']} inet manual\n")
        interfaces_content.append(f"    bond-slaves {' '.join(bond_config['interfaces'])}\n")
        interfaces_content.append(f"    bond-mode {bond_config['mode']}\n")
        interfaces_content.append(f"    bond-miimon {bond_config['miimon']}\n")

        if bond_config['mode'] == '802.3ad':
            interfaces_content.append(f"    bond-lacp-rate {bond_config['lacp_rate']}\n")
            interfaces_content.append(f"    bond-xmit-hash-policy {bond_config['xmit_hash_policy']}\n")

        interfaces_content.append("\n")
    else:
        # Simple ethernet interface
        interfaces_content.append(f"auto {bridge_port}\n")
        interfaces_content.append(f"iface {bridge_port} inet manual\n")
        interfaces_content.append("\n")

    # Configure vmbr0 bridge
    interfaces_content.append("auto vmbr0\n")
    interfaces_content.append("iface vmbr0 inet static\n")
    interfaces_content.append(f"    address {ip_address}\n")
    if gateway:
        interfaces_content.append(f"    gateway {gateway}\n")
    interfaces_content.append(f"    bridge-ports {bridge_port}\n")
    interfaces_content.append("    bridge-stp off\n")
    interfaces_content.append("    bridge-fd 0\n")
    interfaces_content.append("\n")
    interfaces_content.append("source /etc/network/interfaces.d/*\n")

    with open(interfaces_path, 'w') as f:
        f.writelines(interfaces_content)

    print(f"DEBUG: Created {interfaces_path} with contents:")
    print("-" * 80)
    print(''.join(interfaces_content))
    print("-" * 80)

    # Write DNS servers directly to /etc/resolv.conf
    # Proxmox web UI manages /etc/resolv.conf directly, not via dns-nameservers in /etc/network/interfaces
    if dns_servers:
        resolv_conf_path = os.path.join(target, "etc/resolv.conf")
        resolv_content = []
        resolv_content.append("# DNS servers from MAAS deployment\n")
        resolv_content.append("# Can be changed via Proxmox web UI: Node → System → DNS\n")
        for dns_server in dns_servers:
            resolv_content.append(f"nameserver {dns_server}\n")

        with open(resolv_conf_path, 'w') as f:
            f.writelines(resolv_content)

        print(f"DEBUG: Created {resolv_conf_path} with DNS servers: {', '.join(dns_servers)}")

    # CRITICAL: Delete /etc/network/interfaces.new if it exists
    # Proxmox's pvenetcommit.service copies .new -> interfaces on first boot
    # The .new file may contain wrong interface names (ens4) from the image build
    interfaces_new_path = os.path.join(target, "etc/network/interfaces.new")
    if os.path.exists(interfaces_new_path):
        os.remove(interfaces_new_path)
        print(f"DEBUG: Removed {interfaces_new_path} to prevent Proxmox from overwriting our config on first boot")

    configured = True

    if not configured:
        print("WARNING: No interface with IP address found in netplan config")
        return

    # Disable cloud-init network management
    cloud_cfg_dir = os.path.join(target, "etc/cloud/cloud.cfg.d")
    os.makedirs(cloud_cfg_dir, exist_ok=True)

    cloud_cfg_path = os.path.join(cloud_cfg_dir, "99-disable-network-config.cfg")
    with open(cloud_cfg_path, 'w') as f:
        f.write("network: {config: disabled}\n")

    print(f"Created {cloud_cfg_path} to disable cloud-init network management")
    print("Proxmox network configuration complete")


def cleanup():
    """Remove curtin-hooks so its as if we were never here."""
    curtin_dir = os.path.dirname(__file__)
    shutil.rmtree(curtin_dir)


def main():
    state = load_command_environment()
    config = load_command_config(None, state)
    target = state['target']

    print("=" * 80)
    print("CURTIN-HOOKS: Starting custom Proxmox deployment hooks")
    print("=" * 80)
    print(f"DEBUG: Target directory: {target}")
    print(f"DEBUG: Hostname from config: {config.get('hostname', 'NOT SET')}")
    print(f"DEBUG: System UUID from config: {config.get('system_serial', 'NOT SET')}")
    print("-" * 80)

    # Configure Proxmox network with /etc/network/interfaces
    configure_proxmox_network(config, target)

    # Remove network config before passing to builtin_curthooks
    # This prevents builtin_curthooks from writing cloud-init netplan files
    # that would conflict with our /etc/network/interfaces configuration
    config_without_network = config.copy()
    if 'network' in config_without_network:
        del config_without_network['network']
        print("DEBUG: Removed network config from builtin_curthooks to prevent cloud-init conflict")

    # Skip kernel installation - Proxmox kernel is already installed in the image
    # Workaround for Debian 13: Create legacy /etc/apt/sources.list from DEB822 format
    # This prevents curtin from crashing when it tries to read sources.list
    import subprocess
    sources_list_path = os.path.join(target, "etc/apt/sources.list")
    if not os.path.exists(sources_list_path):
        print("DEBUG: Creating /etc/apt/sources.list from DEB822 format for curtin compatibility")
        # Create a minimal sources.list that points to Debian and Proxmox repos
        with open(sources_list_path, 'w') as f:
            f.write("# Auto-generated for curtin compatibility\n")
            f.write("deb http://deb.debian.org/debian trixie main contrib non-free non-free-firmware\n")
            f.write("deb http://deb.debian.org/debian trixie-updates main contrib non-free non-free-firmware\n")
            f.write("deb http://security.debian.org/debian-security trixie-security main contrib non-free non-free-firmware\n")
            f.write("deb http://download.proxmox.com/debian/pve trixie pve-no-subscription\n")

    # CRITICAL FIX: Use {'install': False} to disable kernel installation
    # Setting kernel=None causes AttributeError in curtin's install_kernel() at line 377
    # According to curtin source, install_kernel() checks for kernel: {install: false}
    config_without_network['kernel'] = {'install': False}
    print("=" * 80)
    print("DEBUG: Disabled kernel installation by setting kernel={'install': False}")
    print("DEBUG: Proxmox kernel 6.17.4-2-pve is already installed in the image")
    print("=" * 80)

    print("DEBUG: Config being passed to builtin_curthooks:")
    print(f"  - hostname: {config_without_network.get('hostname', 'NOT SET')}")
    print(f"  - kernel: {config_without_network.get('kernel', 'NOT SET')}")
    print(f"  - network: {config_without_network.get('network', 'REMOVED')}")
    print("-" * 80)

    # Run builtin curthooks for everything else (hostname, users, SSH keys, etc.)
    print("DEBUG: Calling builtin_curthooks()...")
    builtin_curthooks(config_without_network, target, state)
    print("DEBUG: builtin_curthooks() completed successfully")

    # Verify what was actually written
    hostname_path = os.path.join(target, "etc/hostname")
    if os.path.exists(hostname_path):
        with open(hostname_path, 'r') as f:
            actual_hostname = f.read().strip()
        print(f"DEBUG: Actual hostname written to /etc/hostname: {actual_hostname}")
    else:
        print("WARNING: /etc/hostname does not exist after builtin_curthooks!")
        print("DEBUG: MAAS should have set the hostname, checking if issue is in builtin_curthooks")

    interfaces_path = os.path.join(target, "etc/network/interfaces")
    if os.path.exists(interfaces_path):
        with open(interfaces_path, 'r') as f:
            actual_interfaces = f.read()
        print("DEBUG: Final /etc/network/interfaces content:")
        print("-" * 80)
        print(actual_interfaces)
        print("-" * 80)

    print("=" * 80)
    print("CURTIN-HOOKS: Completed successfully, cleaning up...")
    print("=" * 80)
    cleanup()


if __name__ == "__main__":
    main()
